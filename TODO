1. add global class for system validity check. (Finite State Machine)
	1.1. Just implement remaining states.
	1.2 Based on response from ServerMessageHandler, update state.
2. receive message from server, deserialize it and get a KVMessage.
	2.1 Create a Payload based on msgBytes
3. based on KVMessage, perform appropriate actions by client.
	3.1 Handle cases in ServerMEssageHandler
4. Handle Client Commands like help, loglevel and quit
5. implement logging.
6. handle unhandled exceptions.
7. Think of a better Payload (something like HTTP) and a better serialization Message.
	7.1 This should work fine as of now.
8. Store a metadata file for the client, which will have server IP and ranges. Update the file if 
   it contacted wrong node, and retry the request with correct node.
	8.1 Covered in Case handling of ServerMessageHandler.

CURRENT:
1. implement Metadata update function in ServerMessageHandler.
2. Complete Metadata class : read inner classes and complete ServerConfig class that contains server
attributes like Port, BegIndex, endIndex, etc. - done
3. Think of a better RETRY workflow, else, think of processCommand() recursion response.

ISSUES:
1. for how much time does the input stream bytes remain intact. What if the read from KVStore
is called after another round of while(isRunning) is invoked, will the payload become null, or remain there.
2. Can PUT command be issued before CONNECT. The client doesn't know KEY and VALUE at time of connect, so
CONNECT will be issued to a random server. Instead, should PUT issue an internal connect command for
the respective server first?
3. Why can't server itself retry the connect request based on the metadata file it has? Why is it sending
the metadata back to Client? Client should just be receiving the answer.
4. If a value is updated inside a recursive call, does it persist when backtracking, or is rolled
to recursive value in previous recursion stack, i.e., the original one?
5. When is the server passed the metadata when it is started by ECS?

LATEST:
1. For all commands from client, extract the valid server from list of servers it has (from metadata).
2. Create a static metadata instance which can be accessed from any class, which contains the most recent metadata.
3. Server has to check whether it is responsible for the key sent by the user.

FINAL TODO:
1) check if server is responsible for the respective key or not. - done
2) replicate during PUT.
3) RETRY on client side if it gets SERVER_NOT_RESPONSIBLE from server.
4. ask Anant to create a function boolean isResponsible(ServerModel, key)